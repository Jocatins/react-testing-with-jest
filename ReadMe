React testing Library

What to test
1 - Test if the component renders
2 - Test the component renders with props
3 - Test if the component renders in different states
4 - test if the component reacts to events

What not to test
1 - Implementation Details
2 - Third party code

RTL Queries
Queries are the methods that testing library provides to find elements on the page

To find a single element on the page

- getBy
- queryBy
- findBy

To find multiple elements on the page

- getAllBy
- queryAllBy
- findAllBy

`getBy` - This is used to find a single element in the DOM based on a specific criteria.
Example --> `getByRole`, `getByText`, `getByTestId`

`getAllBy` - This set of query method is used to find multiple elements in the DOM based
on specific criteria
Example ---> `getAllByRole`, `getAllByText` , `getAllBy`

`queryBy` - This set of query methods is used to find an element in the DOM.
These queries should be used when you need to find a specific element and you are not sure
will be present in the DOM.
Example ---> `queryByRole`, `queryByText`, `queryByTestId`, `queryBy`

`queryAllBy` - This set of query methods is used to find multiple elements in the DOM.
These methods return an empty array if no matching elements are found.
Example ---> `queryAllByRole`, `queryAllByText`, `queryAllBy`

`findBy` - This set of query methods is used to find a single element in the DOM based
on a specific criteria asynchronously. These queries should be used when you need to find
a specific element in the DOM that may not be present immediately, such as when waiting
for an API call to be completed.
Example ---> `findBy`, `findByRole`, `findByText`

`waitFor` - This utility function is used to wait for a specific condition to be true before continuing
with a test. Examples of conditions, wait for appearance or disappearance of an element, a change in
text-content of an element, for async behaviors.

# Assertions

`Common Matchers`

test('two plus two is four', () => {
expect(2 + 2).toBe(4);
});

test('object assignment', () => {
const data = {one: 1};
data['two'] = 2;
expect(data).toEqual({one: 1, two: 2});
});

`Truthiness`

- toBeNull matches only null
- toBeUndefined matches only undefined
- toBeDefined is the opposite of toBeUndefined
- toBeTruthy matches anything that an if statement treats as true
- toBeFalsy matches anything that an if statement treats as false

e.g
test('null', () => {
const n = null;
expect(n).toBeNull();
expect(n).toBeDefined();
expect(n).not.toBeUndefined();
expect(n).not.toBeTruthy();
expect(n).toBeFalsy();
});

test('zero', () => {
const z = 0;
expect(z).not.toBeNull();
expect(z).toBeDefined();
expect(z).not.toBeUndefined();
expect(z).not.toBeTruthy();
expect(z).toBeFalsy();
});

`Numbers`
test('two plus two', () => {
const value = 2 + 2;
expect(value).toBeGreaterThan(3);
expect(value).toBeGreaterThanOrEqual(3.5);
expect(value).toBeLessThan(5);
expect(value).toBeLessThanOrEqual(4.5);

// toBe and toEqual are equivalent for numbers
expect(value).toBe(4);
expect(value).toEqual(4);
});

- For floating point equality, use toBeCloseTo

test('adding floating point numbers', () => {
const value = 0.1 + 0.2;
//expect(value).toBe(0.3); This won't work because of rounding error
expect(value).toBeCloseTo(0.3); // This works.
});

`String`
You can check strings against regular expressions with toMatch:

test('there is no I in team', () => {
expect('team').not.toMatch(/I/);
});

test('but there is a "stop" in Christoph', () => {
expect('Christoph').toMatch(/stop/);
});

`Arrays and iterables`
You can check if an array or iterable contains a particular item using toContain:

const shoppingList = [
'diapers',
'kleenex',
'trash bags',
'paper towels',
'milk',
];

test('the shopping list has milk on it', () => {
expect(shoppingList).toContain('milk');
expect(new Set(shoppingList)).toContain('milk');
});
